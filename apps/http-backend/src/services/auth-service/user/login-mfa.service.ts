// bms-monorepo/apps/http-backend/src/services/auth-service/user/login-mfa.service.ts

import jwt from 'jsonwebtoken';
import { HttpError } from "@workspace/backend-common/http-error";
import { ILogger, LogContext } from '@workspace/backend-common/logger';
import { jwtConfig } from '@workspace/backend-common/config';
import { prismaClient, Account, Role } from '@workspace/db/client';

// Interfaces for dependencies
import { IOtpService, ILoginMfaService } from '../interfaces/auth.interfaces';
import { LoginVerificationResult } from '../types/auth.types';

// Concrete services for injection
import { AccessTokenService } from '../../token-service/user/access-token.service';
import { RefreshTokenService } from '../../token-service/user/refresh-token.service';
import { UserRole, TokenType } from '@workspace/common/enums'; // Corrected alias import for UserRole and TokenType

export class LoginMfaService implements ILoginMfaService {
    constructor(
        private readonly logger: ILogger,
        private readonly otpService: IOtpService,
        private readonly accessTokenService: AccessTokenService,
        private readonly refreshTokenService: RefreshTokenService
    ) {}

    /**
     * Verifies the OTP provided by the user during MFA login and generates auth tokens upon success.
     * This service is generic and handles OTP verification regardless of whether the OTP was sent via email or phone.
     * @param {string} mfaToken - The MFA token generated during the initial login step.
     * @param {string} otp - The one-time password entered by the user.
     * @param {string} [ipAddress] - The IP address of the request.
     * @param {string} [userAgent] - The user-agent string of the request.
     * @param {string} [correlationId] - Unique ID for the request trace.
     * @returns {Promise<LoginVerificationResult>} A promise that resolves with the access and refresh tokens and user object.
     * @throws {HttpError} Throws an error if the MFA token is invalid/expired or if the OTP is incorrect.
     */
    public async verifyLoginOTP(
        mfaToken: string,
        otp: string,
        ipAddress?: string,
        userAgent?: string,
        correlationId?: string
    ): Promise<LoginVerificationResult> {
        const context: LogContext = {
            module: 'LoginMfaService',
            action: 'VERIFY_LOGIN_OTP',
            ipAddress,
            userAgent,
            correlationId
        };
        let payload: { userId: string };
        let userId: string;

        try {
            // Verify the MFA token (generated by LoginEmailPasswordService or LoginPhoneService)
            payload = jwt.verify(mfaToken, jwtConfig.jwt.mfa.secret) as { userId: string };
            userId = payload.userId;
            context.resourceId = userId;
            context.actorId = userId;
            context.actorType = 'USER';
        } catch (error: any) {
            this.logger.warn(`Invalid or expired MFA token during OTP verification.`, context, { status: 'FAILED' }, error);
            throw new HttpError(401, "Invalid or expired MFA token.");
        }

        // Verify the OTP against Redis (or wherever it's stored)
        const isValidOtp = await this.otpService.verifyOtp(userId, otp);
        if (!isValidOtp) {
            this.logger.warn(`Invalid OTP provided by user ${userId}.`, context, { status: 'FAILED' });
            throw new HttpError(401, "Invalid OTP.");
        }

        // Retrieve user details after successful OTP verification
        const user = await prismaClient.account.findUnique({
            where: { id: userId },
            include: { role: true },
        }) as (Account & { role: Role });

        if (!user) {
            this.logger.error(`User ${userId} not found during OTP verification after valid MFA token.`, context, { status: 'ERROR' });
            throw new HttpError(404, "User not found.");
        }

        // Generate final access and refresh tokens
        const accessToken = await this.accessTokenService.generateAccessToken({
            userId: user.id,
            roleId: user.roleId,
            userRole: user.role.name as UserRole, // Explicitly cast to UserRole enum
            type: TokenType.ACCESS,
            // Conditionally add venueId for specific venue-related admin/manager roles
            // This ensures the token carries the necessary context for authorization middleware.
            ...(user.role.name === UserRole.VENUE_OWNER && user.venueId && { venueId: user.venueId }),
            // ...(user.role.name === UserRole.VENUE_ADMIN && user.venueId && { venueId: user.venueId }),
            // ...(user.role.name === UserRole.SECONDARY_VENUE_NAME_MANAGER && user.venueId && { venueId: user.venueId }),
            // ...(user.role.name === UserRole.VENUE_BOOKING_MANAGER && user.venueId && { venueId: user.venueId }),
            // ...(user.role.name === UserRole.VENUE_OPERATIONS_MANAGER && user.venueId && { venueId: user.venueId }),
            // // For regional admins, you might add 'regionId' or 'managedRegionIds' to the payload
            // // This assumes 'user.managedRegionIds' exists on the Account model for such roles.
            // ...(user.role.name === UserRole.BMSP_REGIONAL_VENUES_ADMIN && user.managedRegionIds && { managedRegionIds: user.managedRegionIds }),
        });
        const refreshToken = await this.refreshTokenService.generateRefreshToken({
            userId: user.id,
            roleId: user.roleId,
            type: TokenType.REFRESH,
        });

        this.logger.success(`User ${user.id} successfully logged in via OTP verification.`, context, { status: 'SUCCESS' });
        return { user, tokens: { accessToken, refreshToken } };
    }
}
